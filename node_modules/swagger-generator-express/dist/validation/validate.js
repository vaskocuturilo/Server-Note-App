'use strict';
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const joi_1 = __importDefault(require("@hapi/joi"));
const validation_error_1 = __importDefault(require("./validation-error"));
const lodash_1 = require("lodash");
const defaultOptions = {
    contextRequest: false,
    allowUnknownHeaders: true,
    allowUnknownBody: true,
    allowUnknownQuery: true,
    allowUnknownParams: true,
    allowUnknownCookies: true,
    status: 400,
    statusText: 'Bad Request'
};
let globalOptions = {};
// maps the corresponding request object to an `express-validation` option
const unknownMap = {
    headers: 'allowUnknownHeaders',
    body: 'allowUnknownBody',
    query: 'allowUnknownQuery',
    params: 'allowUnknownParams',
    cookies: 'allowUnknownCookies'
};
function expressValidation(schema) {
    if (!schema)
        throw new Error('Please provide a validation schema');
    return (req, res, next) => __awaiter(this, void 0, void 0, function* () {
        const errors = [];
        // Set default options
        const options = lodash_1.defaults({}, schema.options || {}, globalOptions, defaultOptions);
        // NOTE: mutates `errors`
        const requestInputType = ['headers', 'body', 'query', 'params', 'cookies'];
        // tslint:disable-next-line:prefer-for-of
        for (let index = 0; index < requestInputType.length; index++) {
            const key = requestInputType[index];
            const allowUnknown = options[unknownMap[key]];
            const entireContext = options.contextRequest ? req : null;
            if (schema[key]) {
                yield validate(errors, req[key], schema[key], key, allowUnknown, entireContext);
            }
        }
        if (errors && errors.length === 0)
            return next();
        // tslint:disable-next-line:new-parens
        return next(new validation_error_1.default(errors, options));
    });
}
exports.default = expressValidation;
;
exports.ValidationError = validation_error_1.default;
exports.options = (opts) => {
    if (!opts) {
        globalOptions = {};
        return;
    }
    globalOptions = lodash_1.defaults({}, globalOptions, opts);
};
/**
 * validate checks the current `Request` for validations
 * NOTE: mutates `request` in case the object is valid.
 */
function validate(errObj, request, schema, location, allowUnknown, context) {
    return __awaiter(this, void 0, void 0, function* () {
        if (!request || !schema)
            return;
        const joiOptions = {
            context: context || request,
            allowUnknown,
            abortEarly: false
        };
        const { error, value } = yield joi_1.default.object(schema).validate(request, joiOptions);
        const errors = error;
        if (!errors || errors.details.length === 0) {
            lodash_1.assignIn(request, value); // joi responses are parsed into JSON
            return;
        }
        // tslint:disable-next-line:no-shadowed-variable
        errors.details.forEach((error) => {
            const errorExists = lodash_1.find(errObj, (item) => {
                if (item && item.field === error.path && item.location === location) {
                    item.messages.push(error.message);
                    item.types.push(error.type);
                    return item;
                }
                return;
            });
            if (!errorExists) {
                errObj.push({
                    field: error.path,
                    location,
                    messages: [error.message],
                    types: [error.type]
                });
            }
        });
        return errObj;
    });
}
;
